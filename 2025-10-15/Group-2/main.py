"""
Task: Replicate what rachel does on countdown - generate an expression to get from smaller numbers to a target number

What we'll need to do:
- Something to generate some smaller numbers (or a hardcoded list)
- Randomly choose 6 smaller numbers
- Randomly choose a target number

- Something to generate an expression that makes the target from the smaller numbers (or tells us if that is not possible)
- Only +-*/ are allowed

"The contestant in control chooses six of 24 shuffled face-down number tiles, arranged into two groups: 20 "small numbers" 
(two each of 1 to 10) and four "large numbers" of 25, 50, 75 and 100. The contestant decides how many large numbers are to be used, 
from none to all four, after which the six tiles are randomly drawn and placed on the board. 
A random three-digit target figure from 100 to 999 is then generated by an electronic machine"

"They may use only the four basic operations of addition, subtraction, multiplication and division[47] and do not have to use all six numbers. 
A number may not be used more times than it appears on the board. Division can only be performed if the result has no remainder 
(i.e., the divisor is a factor of the dividend)."

"""
import random

LARGE_NUMBERS = [25, 50, 75, 100]
SMALL_NUMBERS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] * 2
OPERATIONS = {
    "+": lambda a, b: a + b,
    "*": lambda a, b: a * b,
    "-": lambda a, b: a - b,
    "/": lambda a, b: a // b if a % b else float("inf")
}

def generate_numbers(large_number_count: int) -> list[int]:
    """Generate 6 numbers, with large_number_count from the large numbers and the rest from small"""

    large_nums = LARGE_NUMBERS.copy()
    numbers = []
    for i in range(large_number_count):
        value = random.choice(large_nums)
        numbers.append(value)
        large_nums.remove(value)
    
    small_nums = SMALL_NUMBERS.copy()
    for i in range(6 - large_number_count):
        value = random.choice(small_nums)
        numbers.append(value)
        small_nums.remove(value)

    return numbers
            
def generate_target_number() -> int:
    """Generate a random 3 digit number as a target"""
    return random.randint(100, 999)

# def calculate_expression_recursive(numbers: list[int], target_number: int) -> str | None:
#     """Work out how to get from the numbers to the target_number, returning None if it is not possible"""
    
    
def calculate_expressions(expressions: list[str], target_number: int) -> list[str]:
    """calculate every possible expression and return the equation and the final output"""
    if len(expressions) == 1:
        if eval(expressions[0]) == target_number:
            print(expressions[0], eval(expressions[0]))
            return expressions
        return []
        
    calculated_expressions = []
    for i, first in enumerate(expressions):
        for j, second in enumerate(expressions):
            if i == j:
                continue
            remaining_numbers = [expressions[k] for k in range(len(expressions)) if k not in {i, j}]
            for op in ["+", "-", "*", "//"]:
                if op == "//" and (eval(second) == 0 or eval(first) % eval(second) != 0):
                    continue
                result = f"({first}{op}{second})"
                # a + b
                calculated_expressions.extend(calculate_expressions([result, *remaining_numbers], target_number))
    return calculated_expressions


def main() -> None:
    """Countdown game"""
    target_number = generate_target_number()
    numbers = generate_numbers(3)
    print(f"Attempting to get to {target_number} with: {numbers}")
    print(calculate_expressions(expressions=list(map(str, numbers)), target_number=target_number))



if __name__ == "__main__":
    main()
